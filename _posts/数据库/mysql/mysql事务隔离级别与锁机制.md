---
title: mysql事务隔离级别与锁机制
date: 2020-08-08 21:02:09
tags:
- mysql
categories:
- 数据库
toc: true
---

我们的数据库一般都会并发执行多个事务,多个事务可能并发的对相同的一批数据进行增删改查操作,就可能会导致我们常说的脏读,脏写,幻读,不可重复读等问题.这些问题的本质都是数据库的多事务并发问题,为了解决这一问题,数据库设计了事务隔离机制,锁机制,MVCC多版本并发控制隔离机制,用来解决多事务并发问题.

<!-- more -->

### 事务及其ACID属性

事务是有一组SQL语句组成的逻辑处理单元,具备以下4个属性,简称为事务的ACID属性.

* 原子性(Atomicity): 事务是一个原子操作单元,是最小的执行单位,其对数据的修改,要么全部执行,要么全部都不执行.
* 一致性(Consistent): 在事务开始和完成时,数据保持一致.意味着所有相关的数据规则必须应用于事务的修改,以保持数据的完整性.
* 隔离性(Isolation):并发访问数据库时,一个用户的事务不会被其他事务干扰,各个并发事务之间数据库是独立的.
* 持久性(Durable):一个事务完成之后,它对数据的修改时永久性的,即使出现系统故障也不应该对其有任何影响.

原子性是在操作层次讲的,一致性是在数据层讲的,比如一个事务里,创建订单,减库存,原子性指的是创建订单,减库存必须全部执行成功,或者全部失败,一致性指的是创建订单的数据创建成功,库存的数据减成功.

#### 脏读,脏写,幻读,不可重复读

* 脏写(更新丢失):当两个以上的事务选择同一行数据,然后基于最初的值进行更新时,由于每个事务不知道其他事务的存在,导致发生更新丢失的问题,最后更新的操作覆盖了其他事务所做的更新.

* 脏读:某个事务已经对一条记录做了修改,在事务完成提交前,别的事务读取了这些脏数据,并进行了进一步的处理.如果此时前一个事务rollback,后一个数据读取的数据就是不正确的,不符合一致性要求.简单的说就是一个事务读取到了另外一个事务已经修改但未提交的数据.

* 不可重复读:一个事务在读取某写数据后,再次读取以前读过的数据,发现读出的数据已经发生了改变,或者被删除.简单说就是一个事务内使用相同的语句在不同时刻,读取的数据不一致,不符合隔离性.

* 幻读:一个事务按照相同的条件读取以前检索过的数据,却查询到了其他事务插入了满足查询条件的数据.简单说就是事务A读取到了事务B提交的新增数据,不符合隔离性

幻读和不可重复读的区别是一个是读取到了新增的数据,一个是读取到了修改的数据.

### 事务的隔离级别

 隔离级别|脏读 |不可重复度 |幻读
 ---         | ---    |---|---
 读未提交  | 可能   | 可能      | 可能
 读已提交  | 不可能 | 可能      | 可能
 可重复读  | 不可能  | 不可能    |可能
 可串行化  | 不可能  | 不可能    | 不可能

* 读未提交(READ UNCOMMITED):最低的事务级别,允许读取到未提交的数据,会导致脏读,不可重复度,幻读
* 读已提交(READ COMMITED):允许读取并发事务已经提交的数据,可以组织脏读,但是不可重复度,和幻读可能发生.
* 可重复读(REPEATABLE READ):对同一子弹的多次读取的结果都是一致的,除非数据是被事务本身修改的,可以阻止脏读,不可重复读.但是幻读扔有可能发生.
* 可串行化(SERIALIZABLE):最高的隔离级别,完全服务ACID的隔离级别,所有事务逐个执行.这样事务之间就不可能产生干扰.

可重复读的幻读场景如下:
两个事务A和B,A开启事务先进行一次查询,比如查询出来的结果是100.事务B把100修改为90,并提交,此时A事务还未提交,查询出来还是100.如果A此时对数据进行修改操作,比如对数据-10,那么再执行查询,查询结果就是80.

mysql默认的隔离级别是可重复读,Oracle默认采用的是读已提交.
用Spring开发程序时,如果不设置隔离级别,默认用mysql设置的隔离级别.

### 锁机制

当数据库并发事务时,可能会产生数据不一致,这时需要一些机制来保证事务执行的次序,锁机制就是这样的一种机制.

从性能上锁分为`乐观锁(用版本比对来实现)`和`悲观锁`两种.
从对数据库的操作类型上分为`读锁`和`写锁`,都属于`悲观锁`
`读锁(共享锁)`:针对同一份数据,多个读操作可以同时进行而不会相互影响.
`写锁(排它锁)`:当前写操作没有完成前,会阻断其他写锁和读锁.

从对数据操作的粒度上分为`表锁`和`行锁`

#### 表锁

每次操作锁住整张表,开销小,加锁快,不会出现死锁,但是锁的粒度大,发生锁冲突的概率最高,并发度最低.一般用在表数据迁移的场景.

```bash
## 手动增加表锁
lock table table_name read(write)

## 查看表上加过的锁
show open tables;

## 删除表锁

unlock tables;
```

MyISAM和MEMORY存储引擎采用的表级锁

1. 对MyISAM表的读操作(加读锁) ,不会阻寒其他进程对同一表的读请求,但会阻赛对同一表的写请求。只有当读锁释放后,才会执行其它进程的写操作
2. 对MylSAM表的写操作(加写锁) ,会阻塞其他进程对同一表的读和写操作,只有当写锁释放后,才会执行其它进程的读写操作

#### 行锁

每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高。

InnoDB与MYISAM的最大不同:Innodb支持事务和行级锁

一个session开启事务更新不提交，另一个session更新同一条记录会阻塞，更新不同记录不会阻塞

InnoDB在执行查询语句SELECT时(非串行隔离级别)，不会加锁。但是update、insert、delete操作会加行锁。

#### 间隙锁

间隙锁，锁的就是两个值之间的空隙。Mysql默认级别是repeatable-read，有办法解决幻读问题吗？间隙锁在某些情况下可以解决幻读问题。

假设一个表的主键id有1,2,3,10,20这五条数据.
那么间隙就有id为3-10,10-20,20-正无穷三个区间
在事务A下执行 ` update table Xxx  set name = '张三' where id >8 and id<18 ` ,其他事务在这个范围所包含的所有行记录(包括间隙行记录)以及行记录所在的间隙里插入或修改任何数据，即id在(3,20]区间都无法修改数据，注意最后那个20也是包含在内的

间隙锁是在可重复读隔离级别下才会生效。

#### 其他补充

InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁。

锁定某一行还可以用`lock in share mode`(共享锁) 和`for update`(排它锁)，例如：select * from test_innodb_lock where a = 2 for update; 这样其他session只能读这行数据，修改则会被阻塞，直到锁定行的session提交.

### 锁优化建议

* 尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁
* 合理设计索引，尽量缩小锁的范围
* 尽可能减少检索条件范围，避免间隙锁
* 尽量控制事务大小，减少锁定资源量和时间长度，涉及事务加锁的sql尽量放在事务最后执行
* 尽可能低级别事务隔离

